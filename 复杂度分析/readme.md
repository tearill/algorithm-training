# 算法的时间复杂度和空间复杂度  
## 必要性  
复杂度分析是整个算法学习的精髓  
事后统计的局限很大，测试的结果受到环境(处理器)和数据规模的影响比较大(规模太小结果可能无法反映性能)  

## 大 O 复杂度表示法  
不用具体的测试数据就可以估计算法的执行效率  
```js
function sum(arr) {
  let result = 0
  let len = arr.length
  for(let i = 0; i < len; i++) {
    result += arr[i]
  }
  return result
}
```
1. 第 2、3 行代码分别会被执行 1 次  
2. 循环体内的 result += arr[i] 会被执行 n 次(数组长度)  
3. 循环中的 let i = 0 会被执行一次  
4. 循环的判断 i < len 会被执行 n + 1 次  
5. i++ 会被执行 n 次  
总执行时间：T(n) = 1 + 1 + n + 1 + (n + 1) + n = 3n + 4  
```js
function sum(arr) {
  let result = 0
  let outLen = arr.length
  for(let i = 0; i < outLen; i++) {
    let inLen = arr[i].length
    for(let j = 0; j < inLen; j++) {
      result += arr[i][j]
    }
  }
  return result
}
```
1. 第 2、3 行代码分别会被执行 1 次  
2. let i = 0 执行 1 次  
3. i < outLen 执行 n + 1 次  
4. i++ 执行 n 次  
5. let inLen = arr[i].length 执行 n 次  
6. let j = 0 执行 n 次  
7. j < inLen 执行 n * (n + 1) 次  
8. j++ 执行 n * n 次  
9. result += arr[i][j] 执行 n * n 次  
同样的计算方式 T(n) = 1 + 1 + 1 + (n + 1) + n + n + n * (n + 1) + n * n + n * n = 3n² + 4n + 4  

**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**  
T(n) = O(f(n))  
n 表示数据规模的大小  
f(n)表示每行代码执行的次数总和  

> 算法的时间复杂度表示的不是算法代码到底执行了多少次，而是随着数据规模的增长，算法执行总次数的变化趋势  

对 T(n) 可以做一些简化处理，只需要关注**最大量级**  
1. 如果是常数，直接简化为 1  
2. 如果是多项式，保留指数最高的那一项，并把系数变为 1  
举例：`T(n) = O(3n + 4) => O(n)`、`T(n) = O(3n² + 4n + 4) => O(n²)`  

## 时间复杂度分析  
1. 关注循环次数最多的代码  
  一些常量级别的执行时间，与 n 无关，对于复杂度没有影响  
2. 总的时间复杂度等于量级最大的那段代码的时间复杂度  
  举例来说：一段代码中有单重循环 O(n) 和双重循环 O(n²) => 最后的时间复杂度为 O(n²)  
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积  
  嵌套循环 => 时间复杂度相乘  

## 常见的时间复杂度(从小到大)  
- 常数时间：O(1)  
- 对数时间：O(logn)  
- 线性时间：O(n)  
- 线性对数时间：O(nlogn)  
- 平方、立方等：O(n²)、O(n³) ... O(n^k)  
- 指数时间：O(2^n)  
- 阶乘时间：O(n!)  

## 空间复杂度分析  
对一个算法在运行过程中临时占用存储空间大小的量度，表示内存增长的趋势  
常见的空间复杂度：O(1)、O(n) 和 O(n^2)  
```js
function print(arr) {
  const len = arr.length
  for(let i = 0; i < len; i++) {
    console.log(arr[i])
  }
}
```
使用了内存空间的变量有：arr, len, i  
这些变量在开辟后没有改变过大小，循环中只是对 arr 的输出，没有额外的空间花销，内存占用量不变，所以空间复杂度为 O(1)  
```js
function init(n) {
  let arr = []
  for(let i = 0; i < len; i++) {
    arr[i] = i
  }
  return arr
}
```
arr 最终的大小由 n 决定，随着 n 的增大而增大，呈线性关系，所以空间复杂度为 O(n)  

## 复杂度分析的几个方面  
- 最好情况时间复杂度  
- 最坏情况时间复杂度  
- 平均情况时间复杂度  
- 均摊时间复杂度  

分析举例：  
```js
function find(array, n, x) {
  let pos = -1
  for (let i = 0; i < n; i++) {
    if (array[i] === x) {
      pos =  i
      break
    }
  }
  return pos
}
```
要查找的元素 x 可能出现在数组的任何一个为止，时间复杂度是不同的  
1. 如果数组的第一个元素就是要查找的 x，剩下的 n - 1 个元素就不需要再查找，时间复杂度为 O(1) => `最好情况时间复杂度`  
2. 如果数组中不存在需要查找的元素 x，那就需要把数组所有元素都遍历一遍，时间复杂度为 O(n) => `最坏情况时间复杂度`  
3. 要查找的变量 x 在数组中的位置，有 n + 1 种情况：在数组的 0～n-1 位置中和不在数组中  
  把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n + 1，就可以得到需要遍历的元素个数的平均值  
  即 (1 + 2 + 3 + ... + n) / (n + 1) = n * (n + 3) / 2 * (n + 1) => 系数、低阶、常量可以省略 => O(n) => `平均时间复杂度`    
4. 